AES-128 decryption ALGORITHM - receiving

//notes to remember

// need to accept a range of codes ex. 10 seeds in order can work. can lessen to 5 or smth

// need to program the learn button - will tell the reciever to prepare to receive a code, aftwards press the transmitter, and receiver will decrypt the code and then change it's current seed to the seed of the remote

//time feature
seed is added by the current time in seconds in 24hr format.
decrypter can accept codes up to 10 seconds ahead but and around 5 seconds late.
point is to not allow hackers to block ur transmitter, take the code then use it afterwards.

//DECRYPTION ORDER
first round: addroundkey

thend normal round order is 
inverse shift rows
inverse subbytes
add round key
inverse mix cols

then last round is same -- inverse mix cols

Step 1: roundkey generation (SAME AS ENCRYPTION)


differentiating words in a loop

c=0
L=[w0,w1,w2,w3]

w=L[which word + starting point(counter)]

ex.
wor1=L[0+c]

wor2=L[1+c]

wor3=L[2+c]
etc. etc.

words are created and stuff happens, g function returns, etc.

c+=4

[w0^,w1,w2,w3,w4^,w5,w6,w7]

after this, w4 (w1 in round 1) is w1=[0+c]

key is created 16 bits
  
each 4 bits in order are split into words (4 words)

the 4 words are the words that make up the first key  (yes, round 0 key is the main key)

4 words are added to List of words L




expansionfunc(L): (runs 10 times for AES-128)
	if (first run) then define w1-4 from L
	Gwor4= gfunc(wor4)
	Nwor1 = Gwor4 XOR wor1
	Nwor2 = Nwor1 XOR wor2
	Nwor3 = Nwor2 XOR wor3
	Nwor4 = Nwor3 XOR wor4
	
	Nwor1-4 added to L
	
	wor1-4=Nwor1-4


gfunc(word): 

	move byte[4] to end of index

	move all other bytes to previous index

	byte[1-4]=sbox(byte[1-4])

	rconbyte=rcon()

	nbyte[1-4]=byte[1-4] XOR rconbyte[1-4]

	return nbyte

sbox(byte):
	
	s box conversion. remember, first 4 bits are row, last 4 bits are column

rcon():
	store all RCONs, keep counter either globally or as an argument/attribute of the function you put in
	give proper rcon when called


Step 2: code decryption // round tranformations


when a signal is received, and only whne it is received,
record time: rec_time=time()
decrypt():

	round1code= addRoundKey(enCode)
	mainround(round1code,10)

mainround(code,rounds):
	

	for rounds:
		
		shiftbytes=InvShiftRows(code)
		
		subbytes=rsbox(shiftbytes)
		
		rkbytes= AddRoundKey(subbytes)

		code= InvMixCol(rkbytes)
	
	finalround(code)


finalround(code):

	shiftbytes=InvShiftRows(code)

	sbytes=rsbox(shiftbytes)

	rkbytes= AddRoundKey(sbytes)
		
	return rkbytes

Code decryption round methods:

InverseShiftRows(enCode):

byte[7] moved to [4]
bytes 4 5 6 moved forward 1

byte [10] switch with byte [8]
byte [11] switch with byte [9]

byte [12] moved to [15]
byte 15 14 13 moved back 1

addroundkey(SubCode):

XOR dataset with round key
this is the same as encryption due to the nature of XOR

Example of XOR’s Inversibility
If A is the original data, and K is the key, then:

Encryption: Encrypted = A ⊕ K
Decryption: Decrypted = (A ⊕ K) ⊕ K = A


InverseMixCol(adCode):

Matrix multiplication with predefined matrix

[0E 0B 0D 09,
 09 0E 0B 0D,
 0D 09 0E 0B,
 0B 0D 09 0E]


rsbox(enCode):

substitute bytes using inverse sbox
remember, first 4 bits are row, last 4 bits are column

Step 3:

Seed & time verification

compare both decrypted plaintext with expected plaintext and time:

calculating expected plaintext:

seed=2
plaintextgen():
	if seed>=151:
		seed=2
	plaintext=Fibonacci(seed)
	seed+=1

splitting up received plaintext from decrypt():

first 3 bytes are to be read in as time:

first 6 bits represent seconds

next 6 bits represent minutes

next 5 bits represent hours (24)

next 7 bits are skipped

the following 13 bytes are the seed.


compare seed generated by plaintextgen() and 13 bytes, and 17 bits to rec_time:

if 13bits == plaintext():
	if 17bit in range(rec_time-10(seconds),rec_tim+10): 
		pass, do action.	







