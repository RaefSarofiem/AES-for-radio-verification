AES-128 decryption ALGORITHM - receiving

//notes to remember

// need to accept a range of codes ex. 10 seeds in order can work. can lessen to 5 or smth

// need to program the learn button - will tell the reciever to prepare to receive a code, aftwards press the transmitter, and receiver will decrypt the code and then change it's current seed to the seed of the remote

//time feature
seed is added by the current time in seconds in 24hr format.
decrypter can accept codes up to 10 seconds ahead but and around 5 seconds late.
point is to not allow hackers to block ur transmitter, take the code then use it afterwards.

//DECRYPTION ORDER
first round addroundkey

thend normal round order is 
inverse shift rows
inverse subbytes
add round key
inverse mix cols

then last round is same- inverse mix cols

Step 1: roundkey generation


example of how to differentiate words ina loop
c=0
L=[w0,w1,w2,w3]

w=L[which word + starting point(counter)]
wor1=L[0+c]

wor2=L[1+c]
etc. etc.

words are created and stuff happens, g function returns, etc.

c+=4

[w0^,w1,w2,w3,w4^,w5,w6,w7]


key is created 16 bits
  
each 4 bits in order are split into words (4 words)

the 4 words are the words that make up the first key  (yes, round 0 key is the main key)

4 words are added to List of words L



expansionfunc(L): (runs 10 times)
	if (first run) then define w1-4 from L
	Gwor4= gfunc(wor4)
	Nwor1 = Gwor4 XOR wor1
	Nwor2 = Nwor1 XOR wor2
	Nwor3 = Nwor2 XOR wor3
	Nwor4 = Nwor3 XOR wor4
	
	Nwor1-4 added to L
	
	wor1-4=Nwor1-4




Step 2: code decrypotion // round tranformations

Code decryption round methods:

InverseShiftRows(enCode):

addroundkey(SubCode):

InverseMixCol(adCode):


decrypt():

	round1code= addRoundKey(enCode)
	mainround(round1code,10)

mainround(code,rounds):
	

	for rounds:
		
		shiftbytes=InvShiftRows(code)
		
		subbytes=sbox(shiftbytes)
		
		rkbytes= AddRoundKey(subbytes)

		code= InvMixCol(rkbytes)
	
	finalround(code)


finalround(code):

	shiftbytes=InvShiftRows(code)

	sbytes=sbox(shiftbytes)

	rkbytes= AddRoundKey(sbytes)
		
	

